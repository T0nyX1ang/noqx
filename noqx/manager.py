"""The unified manager for solvers."""

from typing import Any, Dict, List

from noqx.puzzle import Color, Direction, Point, Puzzle
from noqx.puzzle.penpa import PenpaPuzzle

modules: Dict[str, "Solver"] = {}


def load_solver(solver_dir: str, solver_name: str) -> None:
    """Load a solver from a valid directory and record the solver module to a dictionary.

    Args:
        solver_dir: The directory where the solver is located.
        solver_name: The name of the solver to load.

    Raises:
        ValueError: If the solver already exists.
        ImportError: If the solver module cannot be imported.
    """
    if solver_name in modules:
        raise ValueError(f"Solver for {solver_name} already exists.")

    module = __import__(f"{solver_dir}.{solver_name}")
    module_attr = getattr(module, solver_name)

    for attr_name in dir(module_attr):
        attr = getattr(module_attr, attr_name)

        if isinstance(attr, type) and issubclass(attr, Solver) and attr is not Solver:
            puzzle_name = solver_name.lower()
            modules[puzzle_name] = attr()


def list_solver_metadata() -> Dict[str, Any]:
    """List all loaded solver metadata.

    Returns:
        A dictionary containing the attributes for each solver.
    """
    metadata = {}
    for puzzle_name, module in modules.items():
        metadata[puzzle_name] = {
            "name": module.name,
            "category": module.category,
            "aliases": module.aliases,
            "examples": module.examples,
            "parameters": module.parameters,
        }

    return metadata


def prepare_puzzle(puzzle_name: str, puzzle_content: str, param: Dict[str, Any]) -> Puzzle:
    """Convert the raw puzzle from [Penpa+](https://swaroopg92.github.io/penpa-edit/) format to a `Puzzle` object.

    Args:
        puzzle_name: The name of the puzzle.
        puzzle_content: The puzzle content exported in [Penpa+](https://swaroopg92.github.io/penpa-edit/) format.
        param: Additional parameters for the puzzle.

    Returns:
        A converted `Puzzle` object.
    """
    puzzle = PenpaPuzzle(puzzle_name, puzzle_content, param)
    puzzle.decode()

    return puzzle


def generate_program(puzzle: Puzzle) -> str:
    """Generate the solver program.

    * The program generator is based on the puzzle name and the corresponding solver module.

    Args:
        puzzle: A `Puzzle` object for the program.

    Returns:
        The generated program in the Answer Set Programming language.
    """
    module = modules[puzzle.puzzle_name]
    return module.solve(puzzle)


def store_solution(puzzle: Puzzle, model_str: str) -> Puzzle:
    """Convert the solution from [Clingo](https://potassco.org/clingo/) to a `Puzzle` object and refine it.

    * The solution refiner is based on the puzzle name and the corresponding solver module. It does nothing by default.

    * Since the solution from [Clingo](https://potassco.org/clingo/) is in a raw string format, this function
      will parse the string and fill in the corresponding attributes of the `Puzzle` object. The parsing order
      will be: edges, lines, texts (numbers/contents), triangle symbols, colors, other symbols and debugging elements.

    Args:
        puzzle: A `Puzzle` object without stored solution.
        model_str: The raw solution string generated by the [Clingo](https://potassco.org/clingo/) solver.

    Returns:
        A `Puzzle` object with the stored solution.

    """
    module = modules[puzzle.puzzle_name]

    solution_data = tuple(str(model_str).split())  # raw solution converted from clingo
    solution = PenpaPuzzle(puzzle.puzzle_name, puzzle.content, puzzle.param)
    solution.decode()
    solution.clear()

    for item in solution_data:
        _type, _data = item.replace("(", " ").replace(")", " ").split()
        data = _data.split(",")

        r, c = tuple(map(int, data[:2]))  # ensure the first two elements of data is the row and column

        if _type.startswith("edge_"):
            for d in [Direction.TOP, Direction.LEFT, Direction.TOP_LEFT, Direction.DIAG_UP, Direction.DIAG_DOWN]:
                if _type == f"edge_{d}":
                    solution.edge[Point(r, c, d)] = True

        elif _type.startswith("grid_"):
            grid_direction = str(data[2]).replace('"', "")
            if puzzle.puzzle_name == "hashi":
                solution.line[Point(r, c, label=f"{grid_direction}_{data[3]}")] = True
            else:
                solution.line[Point(r, c, label=grid_direction)] = True

        elif _type.startswith("number"):
            solution.text[Point(r, c, Direction.CENTER, "normal")] = int(data[2])

        elif _type.startswith("content"):
            solution.text[Point(r, c, Direction.CENTER, "normal")] = str(data[2]).replace('"', "")

        elif _type == "triangle":
            shaka_dict = {'"ul"': "1", '"ur"': "4", '"dl"': "2", '"dr"': "3"}
            solution.symbol[Point(r, c, Direction.CENTER)] = f"tri__{shaka_dict[data[2]]}"

        elif _type == "gray":
            solution.surface[Point(r, c)] = Color.GRAY
        elif _type == "black":
            solution.surface[Point(r, c)] = Color.BLACK

        elif len(data) == 2:
            solution.symbol[Point(r, c, Direction.CENTER)] = str(_type)

        else:  # pragma: no cover
            solution.text[Point(r, c, Direction.CENTER, "normal")] = int(data[2])  # for debugging

    module.refine(solution)
    return solution


class Solver:
    """Base class to create solvers.

    * New solvers should inherit this class and set appropriate attribute values.

    Attributes:
        name: The name of the solver (default is `Unknown`).
        category: The category of the solver (default is `unk`).
        aliases: A list of alternative names for the solver (default is `[]`).
        examples: A list of example puzzles for the solver (default is `[]`).
        parameters: A dictionary of parameters for the solver (default is `{}`).
    """

    def __init__(self):
        """Initialize an internal program."""
        self._program: List[str] = []

    def add_program_line(self, line: str):
        """Add a line to the internal program.

        Args:
            line: A line in the Answer Set Programming language.
        """
        if line != "":
            self._program.append(line.strip())

    @property
    def program(self) -> str:
        """Convert the internal program as a string.

        Returns:
            The program in the Answer Set Programming language.
        """
        return "\n".join(self._program)

    def reset(self):
        """Clear the internal program.

        * Make sure to reset the program before generating a new one.
        """
        self._program.clear()

    def solve(self, _: Puzzle) -> str:
        """Generate the solver program.

        * New solvers should at least implement this method.

        Args:
            _: A `Puzzle` object for the program.

        Returns:
            The generated program in the Answer Set Programming language.

        Raises:
            NotImplementedError: If this method is not implemented.
        """
        raise NotImplementedError("Solver program not implemented.")

    def refine(self, solution: Puzzle) -> Puzzle:
        """Refine the solution.

        Args:
            solution: A `Puzzle` object to be refined.

        Returns:
            A refined `Puzzle` object.
        """
        return solution

    name: str = "Unknown"
    category: str = "unk"
    aliases: List[str] = []
    examples: List[Dict[str, Any]] = []
    parameters: Dict[str, Any] = {}
